CIS 4362 - Introduction to Cryptology
Ex04
Andrew Helms
11/13/20

I approached the genKeys program by first taking in the number of rounds and validating it. Then I take in the user's input and pass it and the number of rounds to a function that returns the appropriate output. I then validate the user input and put it into a set of column vectors of size 3. After 3 of these valid column vectors are generated and pushed onto another vector, I procede to generate the round keys. I generate each column vector of the round keys iteratively and push them individually onto the main vector that holds the column vectors. I then iterate through the column vectors and format them into an output string, then return that output string.

I approached the SAESe program by first taking in the number of rounds and validating it. Then I take in the master key, check its length, and process it in the same way as the genKeys program to get a vector of column vectors that represents the round keys. Then I take in the user's input and pass it, the number of rounds, and the round keys to a function that returns the appropriate output. The function first validates and processes the user input into a vector that holds a block of 3 column vectors that each hold 3 characters. Then the initial whitening is done with the master key and the input is processed through rounds as specified. Then the ciphertext that is represented as blocks of 3 column vectors is copied over to an output string and the spaces and line breaks are added as needed for proper output formatting.

I approached the SAESd program by first taking in the number of rounds and validating it. Then I take in the master key, check its length, and process it in the same way as the genKeys program to get a vector of column vectors that represents the round keys. Then I take in the user's input and pass it, the number of rounds, and the round keys to a function that returns the appropriate output. The function first validates and processes the user input into a vector that holds a block of 3 column vectors that each hold 3 characters. Then the input is processed through rounds as specified and the un-whitening is done with the master key. Then the plaintext that is represented as blocks of 3 column vectors is copied over to an output string and the spaces and line breaks are added as needed for proper output formatting.

The only major thing that confused me was the example provided for SAESe. I didn't see a number of rounds or a master key specified, only the input text. I guessed that it was the same as the example for genKeys and it seemed to work. I also didn't realize that matrix multiplication of AxB is the same as multiplication on individual columns of B. I first tried to implement it on the columns and realized they were the same when the code was the same as normal matrix multiplication on the entire block.