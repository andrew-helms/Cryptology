CIS 4362 - Introduction to Cryptology
Ex03
Andrew Helms
10/16/20

I approached the multiplicative inverse program like I have approached the other exercises. I first checked and validated the commmand line argument and then took in the user's input until EOF was reached. Then I took the input and passed it into a function that calculates the multiplicative inverse from a string input of numbers and outputs a string of the output. The function uses a reference string to validate each line and then calculate the multiplicative inverse if it is valid. I didn't encounter any problems doing this program. I tested the program by giving it many different valid inputs and a few inputs that were invalid for each way it could be invalid.

I approached the matrix inverse program in a slightly different way than the last. I took in the user's input in the same way but checked if the matrix was valid before passing it into the invert matrix function. I passed in the matrix as a 2d vector and had the function return a 2d vector. I had it return the original input if the vector wasn't invertible so it wouldn't input anything. The function calculates the determinant and, if the matrix is invertible, calculates the inverse of the determinant using the Extended Euclidean Algorithm. Then the element values for the output matrix are calculated from the input matrix and determinant. The only issue I ran into while programming and testing was that the modulo operator in C++ doens't always return a positive number, so I had to take the modulo, add 37, and then take the modulo again to ensure that the output was always between 0 and 36. I tested it by giving it many different valid and invalid inputs.

I approached the hill cipher program in a similar way as the last two programs. I first checked and validated the command line argument and verified the key is a valid matrix. Then the input and the key, represented as a 2d vector of integers, is passed into the hill cipher function. That function outputs the formatted string of output characters. It goes through the input by individual characters and converts uppercase characters to lowercase. It then adds the character to a column vector, represented by a vector, if the character is contained in a reference string. The column vector doens't store the characters themselves, but the index of the character in the reference string. Once the column vector is full, it is multiplied with the key matrix to get a set of three output character indices. These indices are converted back to characters using a different reference string and added to an output string. This process continues until no input characters remain. If they column vector isn't full when input characters run out, then there were'nt enough valid input characters and an error should be thrown. Lastly the output string is formatted with spaces and line breaks as programs in other exercises have been, and it is returned. I did't run into any problems while programming or testing the hill cipher. I tested it by giving it many valid and invalid key matrices and input text lengths.

I haven't really had to program matrix operations before so it was interesting to try to do it efficiently. I'm sure the method I came up with wasn't ideal, but it worked well enough for this application.